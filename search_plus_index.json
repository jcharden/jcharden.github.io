{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Have fun exploring~ Copyright © 程潇 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 16:50:42 "},"Chapter1/":{"url":"Chapter1/","title":"Chapter1:VulDetection","keywords":"","body":"Chapter1:VulDetection Vulnerability Detection & related Content Section1:Slicing gives the defination and lists some papers related to program slicing technology. Section2:Survey lists four categories(i.e. Vulnerability detection, Defect/Fault prediction, Clone detection and Code representation) related to program analysis using deep learning or machine learning. Copyright © 程潇 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-26 10:23:42 "},"Chapter1/Slicing.html":{"url":"Chapter1/Slicing.html","title":"Section1:Slicing","keywords":"","body":"Section1:Slicing The defination of program slicing first appears in the paper \"Program Slicing\" on IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. SE-10, NO. 4, JULY 1984 by MARK WEISER. Program slicing is a method for automatically decomposing programs by analyzing their data flow and control flow. Starting from a subset of a program's behavior, slicing reduces that program to a minimal form which still produces that behavior. The reduced program, called a \"slice,\" is an independent program guaranteed to represent faithfully the original program within the domain of the specified subset of behavior. Some properties of slices are presented. In particular, finding statement-minimal slices is in general unsolvable, but using data flow analysis is sufficient to find approximate slices. Potential applications include automatic slicing tools for debuggng and parallel processing of slices. Copyright © 程潇 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 13:34:28 "},"Chapter1/Slicing_APS.html":{"url":"Chapter1/Slicing_APS.html","title":"Abstract Program Slicing","keywords":"","body":"Abstract Program Slicing: an Abstract Interpretation-based approach to Program Slicing pdf Abstract 基于传统的slicing提出了抽象slicing，只考虑data的属性而不是准确的值。 Note Program slicing is used for reducing the size of programs to analyze. Nevertheless, sometimes this reduction is not sufficient for really improving an analysis. Suppose that some variables at some point of execution do not have a desired property (for example, that they are different from 0, or from null); in order to understand where the error occurred, it would be useful to find those statements which affect such a property of these variables. Standard slicing may return too many statements, making it hard for the programmer to realize which one caused the error. Thought 为实现相同功能可能有很多种程序写法，通过抽象可以让程序泛型化，特征表示更精准，可以避免混淆。 Copyright © 程潇 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 22:41:56 "},"Chapter1/Slicing_SNS.html":{"url":"Chapter1/Slicing_SNS.html","title":"STRUCTURED NEURAL SUMMARIZATION","keywords":"","body":"STRUCTURED NEURAL SUMMARIZATION pdf Abstract 解决了将富含冗余信息的长文本转化为更精确的短文本抽象，该文章将weakly structured data即text转化为highly structured data即graph，这里保留了文本的上下文关系以及token的long-distance关系，然后结合图神经网络进行学习。 Note 关键在于如何将text转成graph，这里用一张图来说明： 文章用来CoreNLP来得到entity，有三种连接关系，next表示顺序关系，in表示从属关系，ref表示引用关系。 Thought 可以把每一个statement再细分成token，然后用AST或者其他方式组织这些token，这样可以最大程度避免丢失由于长文本导致的statement中token信息丢失的问题，但是得到的图会更大，以及如何用AST去表示每条statement是一个待解决问题。 Copyright © 程潇 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 22:42:49 "},"Chapter1/Slicing_CV.html":{"url":"Chapter1/Slicing_CV.html","title":"Code Vectors","keywords":"","body":"Code Vectors: Understanding Programs Through Embedded Abstracted Symbolic Traces pdf Abstract 采用abstractions of traces obtained from symbolic execution of a program来表示程序，将这些traces转化为向量，这些向量即代码的特征表示。 Note 关键在于如何抽象以及如何做word embedding 关于如何做抽象： 关于如何做word embedding Thought 提供了一个做slice以及word,statement embedding的思路 做slice可以结合符号执行，embedding可以用抽象表示，这样可以减少token的数量，以及删除冗余信息。 Copyright © 程潇 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 22:42:10 "},"Chapter1/Slicing_ORBS.html":{"url":"Chapter1/Slicing_ORBS.html","title":"ORBS","keywords":"","body":"ORBS:Language-Independent Program Slicing pdf Abstract 通过删除特定语句，且删除后对于特定输入，依然能得到原来的结果，不断删除。这是一个动态的slicing，需要testcase输入。 Approach 给了一个slice的定义 Thought 提供了一个slice的思路，通过删除之后而不改变语义的方法。 Copyright © 程潇 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 22:42:41 "},"Chapter1/Slicing_MOBS.html":{"url":"Chapter1/Slicing_MOBS.html","title":"MOBS","keywords":"","body":"MOBS: Multi-Operator Observation-Based Slicing using Lexical Approximation of Program Dependence pdf Abstract 改进了ORBS，通过文本相似度 Note 通过vsm和lda算法计算和待删除的lines和已经可以确定删除的lines的相似度，如果很相似则删掉。 Thought 可以通过计算相似度的方法来对slice进行一些预处理 Copyright © 程潇 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 22:42:21 "},"Chapter1/Slicing_TZS.html":{"url":"Chapter1/Slicing_TZS.html","title":"TZSlicer","keywords":"","body":"TZSlicer pdf Abstract 针对information leakage的问题，提出了一种能自动识别发生information leakage的代码位置，介绍了slicing的方法。 Note 框架 Taint analyzer 三个粒度进行taint： Method-level Tainting (TZ-M), which taints the program at the function level and generates security sensitive functions and non-sensitive functions; Block-level Tainting (TZ-B), which further taints the internal code blocks (e.g., branches) within the functions and generates security sensitive and non-sensitive blocks; and Line-level Tainting (TZ-L), in which each line of the program is labeled as either security sensitive or non-sensitive based on the taint propagation. Program Slicer & Slice Optimizer An important design principle of the Program Slicer is to ensure that the sliced programs are functionally equivalent to the original program. Employ dynamic taint analysis that is dependent upon the specific executions of the sliced programs, which has been shown to achieve significantly smaller slices than static slicing. TZ-M Slicing TZ-B Slicing TZ-L Slicing Thought 结合动态的taint analysis可以得到更小而精的slice。 Copyright © 程潇 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-25 22:43:02 "},"Chapter1/Survey.html":{"url":"Chapter1/Survey.html","title":"Section2:Survey","keywords":"","body":"Section2:Survey tagsstart properties labels texts tokens ASTs graphs tagsstop A survey of program analysis using deep-learning or machine-learning. Mainly include: Vulnerability detection Defect/Fault prediction Clone detection Most use Code representation method to learn semantic representation of programs. The Code representation mainly includes properties, labels, texts, tokens, ASTs and graphs. Copyright © 程潇 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-26 12:42:53 "},"Chapter1/Survey_vd.html":{"url":"Chapter1/Survey_vd.html","title":"Vulnerability detection","keywords":"","body":"Vulnerability detection Detecting and fixing complicated, emerging and wide-ranging vulnerabilities in modern software vulnerabilities by extracting vulnerability features from source code and encoding bug patterns into neural networks. Copyright © 程潇 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-26 10:35:19 "},"Chapter1/Survey_sdp.html":{"url":"Chapter1/Survey_sdp.html","title":"Defect/Fault prediction","keywords":"","body":"Defect/Fault prediction Predicting defective code regions and locating fault to help developers find bugs and prioritize their testing efforts by learning semantic representation of programs automatically from source code. Copyright © 程潇 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-26 12:38:09 "},"Chapter1/Survey/ALSFFDP.html":{"url":"Chapter1/Survey/ALSFFDP.html","title":"Automatically Learning Semantic Features for Defect Prediction","keywords":"","body":"Automatically Learning Semantic Features for Defect Prediction tagsstart ASTs tagsstop pdf Leverage Deep Belief Network (DBN) to automatically learn semantic features from token vectors extracted from programs’ Abstract Syntax Trees (ASTs). Motivating example Prediction process 1) nodes of method invocations and class instance creations 2) declaration nodes, i.e., method declarations, type declarations, and enum declarations, and 3) control-flow nodes such as while statements, catch clauses, if statements, throw statements. Copyright © 程潇 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-26 12:32:30 "},"Chapter1/Survey/DeepFL.html":{"url":"Chapter1/Survey/DeepFL.html","title":"DeepFL: Integrating Multiple Fault Diagnosis Dimensions for Deep Fault Localization","keywords":"","body":"DeepFL: Integrating Multiple Fault Diagnosis Dimensions for Deep Fault Localization tagsstart texts properties labels tagsstop pdf Approach Collect various suspiciousness-value-based, fault-proneness-based and textual-similarity-based features from the fault localization, defect prediction and information retrieval areas. Working at method level. Spectrum-based Suspiciousness learn faulty locations based on suspiciousness values computed by 25 traditional spectrum-based fault localization techniques. Mutation-based Suspiciousness Complexity-based Fault Proneness code complexity metrics have been widely used to estimate the fault-proneness of code elements in the field of defect prediction. we collect all the 21 widely-used code complexity metrics (shown in Table 1) for the method level (since DeepFL works at the method level). In addition, we also collect the statistics for each type of Java ASM [67] bytecode instructions shown Table 1. In total, we have 37 complexity-based features. Textual Similarity Information We investigate the textual similarity between source code methods and failed test information. Similar with the structured information retrieval work, we also collect different fields for both queries and documents. Query fields come from failed tests, including the name of failed tests, the source code of failed tests and the complete failure message (including exception type, message, and stacktrace). Document fields come from source code methods, including: the full qualified name of the method, accessed classes, method invocations, used variables, and comments. Each field of query can be searched on each field of document, yielding 15 combinations. For each combination, we calculate the similarity score between the query field and the document field by using the popular TF.IDF model. Then, we treat the similarity scores of the 15 combinations as 15 features for our DeepFL. Copyright © 程潇 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-26 13:15:41 "},"Chapter1/Survey_cd.html":{"url":"Chapter1/Survey_cd.html","title":"Clone detection","keywords":"","body":"Clone detection Identifying code clone depending on effective existing/latent features to represent code fragments. Copyright © 程潇 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-26 12:36:58 "},"Chapter1/Survey/DLCFFCCD.html":{"url":"Chapter1/Survey/DLCFFCCD.html","title":"Deep Learning Code Fragments for Code Clone Detection","keywords":"","body":"Deep Learning Code Fragments for Code Clone Detection tagsstart ASTs tagsstop pdf Approach Proposed a learning-based approach for clone detection. Generally, there are four clone types. Type I: Identical fragments except for variations in comments and layout. Type II: Identical fragments except for variations in identifier names and literal values in addition to Type I differences. Type III: Syntactically similar fragments that differ at the statement level. The fragments have statements added, modified, or removed with respect to each other, in addition to Type II differences - Type IV: Syntactically dissimilar fragments that implement the same functionality. Type I, II, and III clones indicate textual similarity whereas Type IV clones indicate functional similarity. The first part we use a particular type of language model, an RtNN, to map each term in a fragment to an embedding. The second part we use the language’s grammar and a recursive learning procedure, implemented as an RvNN, to encode arbitrarily long sequences of embeddings to characterize fragments. 拓展 Recently, Language models' effectiveness has suffused SE tasks such as code suggestion , deriving readable string test inputs to reduce human oracle cost , predicting comments to improve search over code bases and code categorization , improving error reporting , generating feasible test cases to improve coverage , improving stylistic consistency to aid readability and maintainability, code migration, synthesizing API completions , code review , fault localization , and suggesting method and class names. Copyright © 程潇 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-26 13:16:00 "},"Chapter1/Survey/ANNSCRBOAST.html":{"url":"Chapter1/Survey/ANNSCRBOAST.html","title":"A Novel Neural Source Code Representation based on Abstract Syntax Tree","keywords":"","body":"A Novel Neural Source Code Representation based on Abstract Syntax Tree tagsstart ASTs tagsstop pdf Overview Propose a novel AST-based Neural Network (ASTNN) for source code representation. An example of AST Statement nodes (marked in red) Approach First, we parse a source code fragment into an AST, and design a preorder traversal algorithm to split each AST to a sequence of statement trees (ST-trees, which are trees consisting of statement nodes as roots and corresponding AST nodes of the statements), as illustrated in Figure 1. All ST-trees are encoded by the Statement Encoder to vectors, denoted as e1, · · · , et.(preorder travel+word2vec+mp) We then use Bidirectional Gated Recurrent Unit (Bi-GRU), to model the naturalness of the statements. The hidden states of Bi-GRU are sampled into a single vector by pooling, which is the representation of the code fragment. Copyright © 程潇 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-26 13:15:14 "},"Chapter1/Survey/DECKARD.html":{"url":"Chapter1/Survey/DECKARD.html","title":"DECKARD: Scalable and Accurate Tree-based Detection of Code Clones","keywords":"","body":"DECKARD: Scalable and Accurate Tree-based Detection of Code Clones tagsstart ASTs tagsstop pdf Overview Present an efficient algorithm for identifying similar subtrees and apply it to tree representations of source code. Our algorithm is based on a novel characterization of subtrees with numerical vectors in the Euclidean space and an efficient algorithm to cluster these vectors w.r.t. the Euclidean distance metric. Subtrees with vectors in one cluster are considered similar. Approach Characteristic Vectors The characteristic vector of a subtree is a point in the Euclidean space, where each ci represents the count of occurrences of a specific tree pattern in the subtree. Vector Merging Sum up the vectors of certain node sequences. The choice of which nodes in the tree to merge is important; these nodes must make good boundaries among cloned code, while not frequently containing large subtrees. Vector Clustering and Post-Processing clusters similar characteristic vectors w.r.t. their Euclidean distances to detect cloned code. Copyright © 程潇 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-27 10:11:51 "},"Chapter1/Survey/SourcererCC.html":{"url":"Chapter1/Survey/SourcererCC.html","title":"SourcererCC: Scaling Code Clone Detection to Big Code","keywords":"","body":"SourcererCC: Scaling Code Clone Detection to Big Code tagsstart tokens tagsstop pdf Overview A token-based clone detector that targets three clone types, and exploits an index to achieve scalability to large inter-project repositories using a standard workstation. Approach Two primary stages: (i) partial index creation; and (ii) clone detection. Partial index creation Parses the code blocks from the source files, and tokenizes them with a simple scanner that is aware of token and block semantics of a given language(java c c#). From the code blocks it builds an inverted index mapping tokens to the blocks that contains them. Unlike previous approaches, it does not create an index of all tokens in the code blocks, instead it uses a filtering heuristic to construct a partial index of only a subset of the tokens in each block. Clone detection Iterates through all of the code blocks, retrieves their candidate clone blocks from the index. As per the filtering heuristic, only the tokens within the sub-block are used to query the index, which reduces the number of candidate blocks. After candidates are retrieved, SourcererCC uses another filtering heuristic, which exploits ordering of the tokens in a codeblock to measure a live upper-bound and lower-bound of similarity scores between the query and candidate blocks. Candidates whose upper-bound falls below the similarity threshold are eliminated immediately without further processing. Similarly, candidates are accepted as soon as their lower-bound exceeds the similarity threshold. This is repeated until the clones of every code block are located. SourcererCC exploits symmetry to avoid detecting the same clone twice. Copyright © 程潇 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-27 10:11:44 "},"Chapter1/Survey_cr.html":{"url":"Chapter1/Survey_cr.html","title":"Code representation","keywords":"","body":"Code representation learn semantic representation of programs. The Code representation mainly includes properties, labels, texts, tokens, ASTs and graphs. properties: labels: based on suspiciousness values computed by other traditional/non-traditional techniques. texts: such as traces from symbolic execution, from data flow slicing. tokens: such as method tokens. ASTs graphs: such as cfg, dfg. Copyright © 程潇 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-26 12:47:42 "},"Chapter1/Survey/CVUPTEAST.html":{"url":"Chapter1/Survey/CVUPTEAST.html","title":"Code Vectors: Understanding Programs Through Embedded Abstracted Symbolic Traces","keywords":"","body":"Code Vectors: Understanding Programs Through Embedded Abstracted Symbolic Traces tagsstart texts tagsstop pdf Approach 采用abstractions of traces obtained from symbolic execution of a program来表示程序，将这些traces转化为向量，这些向量即代码的特征表示。 关键在于如何抽象以及如何做word embedding 关于如何做抽象： 关于如何做word embedding Copyright © 程潇 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-26 13:15:27 "},"tags.html":{"url":"tags.html","title":"Tags","keywords":"","body":"Tags Copyright © 程潇 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-26 12:22:01 properties Section2:Survey DeepFL: Integrating Multiple Fault Diagnosis Dimensions for Deep Fault Localization labels Section2:Survey DeepFL: Integrating Multiple Fault Diagnosis Dimensions for Deep Fault Localization texts Section2:Survey DeepFL: Integrating Multiple Fault Diagnosis Dimensions for Deep Fault Localization Code Vectors: Understanding Programs Through Embedded Abstracted Symbolic Traces tokens Section2:Survey SourcererCC: Scaling Code Clone Detection to Big Code ASTs Section2:Survey Automatically Learning Semantic Features for Defect Prediction Deep Learning Code Fragments for Code Clone Detection A Novel Neural Source Code Representation based on Abstract Syntax Tree DECKARD: Scalable and Accurate Tree-based Detection of Code Clones graphs Section2:Survey "}}